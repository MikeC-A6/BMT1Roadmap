# Server Application\n\nThis directory contains the Node.js backend server for the Project Roadmap application. It is built using Express.js, uses Drizzle ORM for interacting with a PostgreSQL database (NeonDB), and integrates with the GitHub API to fetch issue data.\n\n## Overview\n\nThe server provides a RESTful API for the client application to:\n*   Manage (CRUD) roadmap cards.\n*   Fetch and cache GitHub issues relevant to the roadmap.\n*   Handle user authentication (foundations exist with Passport.js, but full implementation details are not covered here).\n*   Serve the client application in development (via Vite middleware) and production (statically).\n\n## Technologies Used\n\n*   **Runtime**: Node.js\n*   **Framework**: Express.js\n*   **Database ORM**: Drizzle ORM\n*   **Database**: PostgreSQL (configured for NeonDB serverless driver)\n*   **Schema Validation**: Zod (used with Drizzle and for API request validation)\n*   **API Communication**: `node-fetch` (for GitHub API)\n*   **Development**: `tsx` for running TypeScript directly, Vite for HMR via `server/vite.ts`.\n*   **Production Build**: `esbuild`\n*   **Session Management**: `express-session` (with `connect-pg-simple` or `memorystore` potentially)\n*   **Authentication**: `passport`, `passport-local` (basic setup present)\n*   **Language**: TypeScript\n\n## Project Structure (`server/`)\n\n```\nserver/\n├── index.ts            # Main server entry point, Express app setup, middleware, Vite integration.\n├── routes.ts           # API route definitions, including GitHub API interaction logic.\n├── db.ts               # Drizzle ORM and database connection setup (NeonDB).\n├── storage.ts          # Data access layer (class `DatabaseStorage`) abstracting database operations.\n├── vite.ts             # Vite middleware setup for development.\n└── ... (potentially other modules or utility files)\n```\n\n*   **`index.ts`**: Initializes the Express application, sets up middleware (JSON parsing, logging, error handling), integrates Vite for development, and starts the HTTP server.\n*   **`routes.ts`**: Defines all API endpoints (e.g., `/api/roadmap/cards`, `/api/github/issues`). Currently, this file also contains the logic for fetching and caching GitHub issues.\n*   **`db.ts`**: Configures the Drizzle ORM client using the Neon serverless driver and exports the database instance (`db`) and connection pool (`pool`). It expects a `DATABASE_URL` environment variable.\n*   **`storage.ts`**: Implements a `DatabaseStorage` class that provides methods for interacting with the database (users, roadmap cards, GitHub issues). This class uses the `db` instance from `db.ts`.\n*   **`vite.ts`**: Contains functions to integrate Vite as middleware for serving the client during development.\n\n## API Endpoints\n\nThe primary API endpoints are prefixed with `/api`.\n\n*   **Roadmap Cards**: `POST, GET, PATCH, DELETE /api/roadmap/cards` and `GET /api/roadmap/cards/:id`, `POST /api/roadmap/cards/batch`\n    *   Manages roadmap card entities.\n    *   Uses Zod schemas from `@shared/schema` for validation.\n*   **GitHub Issues**: `GET /api/github/issues`, `GET /api/github/issues/refresh`\n    *   `GET /api/github/issues`: Returns cached GitHub issues.\n    *   `GET /api/github/issues/refresh`: Forces a refresh of GitHub issues from the GitHub API and updates the cache (both in-memory and database).\n\n(Refer to `server/routes.ts` for detailed request/response structures and logic.)\n\n## Database\n\n*   The application uses Drizzle ORM with a PostgreSQL database (specifically configured for NeonDB).\n*   Database schemas are defined in `shared/schema.ts`.\n*   Migrations or schema pushing is handled by Drizzle Kit. Use `npm run db:push` (from the root directory) to apply schema changes to your database.\n\n## Environment Variables\n\nKey environment variables required by the server (typically set in a `.env` file at the project root):\n\n*   `DATABASE_URL`: **Required**. The connection string for your PostgreSQL database (e.g., `postgresql://user:password@host:port/dbname?sslmode=require`).\n*   `GITHUB_TOKEN`: **Optional but Recommended**. A GitHub Personal Access Token. Required to fetch data from the GitHub API, especially for private repositories or to avoid rate limiting. The token should have `repo` scope for accessing repository data and issues.\n*   `PORT`: **Optional**. The port on which the server will listen. Defaults to `5000` as per `server/index.ts`.\n*   `NODE_ENV`: `development` or `production`. Controls aspects like Vite integration and logging.\n\n## Running the Server\n\n*   **Development**: `npm run dev` (from the root directory). This starts the server using `tsx` and enables Vite for client HMR.\n*   **Production**: `npm run start` (from the root directory). This runs the `esbuild`-compiled server from the `dist/` directory.\n\n## Refactoring Opportunities\n\nThe current server structure is functional, but certain areas could be refactored for better maintainability, testability, and separation of concerns.\n\n### 1. GitHub Service Abstraction\n\n**Current Situation**:\nGitHub API interaction logic (fetching, caching, constants like `GITHUB_REPO`) is currently embedded within `server/routes.ts`.\n\n**Proposed Refactoring**:\nExtract all GitHub-related functionality into a dedicated service module.\n\n1.  **Create a new directory**: `server/services/`\n2.  **Create a new file**: `server/services/githubService.ts`\n3.  **Move GitHub Logic**: Migrate functions like `fetchGitHubIssuesFromApi`, `fetchGitHubIssuesFromCache`, related constants (`GITHUB_API_URL`, `GITHUB_REPO`, `REQUIRED_LABELS`), and types (`GitHubIssue`) into `githubService.ts`.\n4.  **Define a Service Interface/Class**:\n    ```typescript\n    // server/services/githubService.ts\n    import fetch from \'node-fetch\';\n    import { storage, IStorage } from \'../storage\'; // Assuming storage is accessible\n    import { GITHUB_TOKEN, GITHUB_REPO_OWNER, GITHUB_REPO_NAME, GITHUB_PROJECT_LABELS } from \'../config\'; // Or manage env vars directly\n\n    // Define an interface for the structure of a GitHub issue\n    export interface GitHubIssue {\n      id: string;\n      number: number;\n      title: string;\n      url: string;\n      labels: string[];\n      // Add other relevant fields: state, assignee, body, etc.\n    }\n\n    export class GitHubService {\n      private readonly GITHUB_API_URL = \'https://api.github.com/graphql\';\n      private token: string;\n      private repoOwner: string;\n      private repoName: string;\n      private requiredLabels: string[];\n      private inMemoryCache: GitHubIssue[] = [];\n      private storage: IStorage;\n\n      constructor(token: string, repoOwner: string, repoName: string, requiredLabels: string[], dbStorage: IStorage) {\n        this.token = token;\n        this.repoOwner = repoOwner; // e.g., \'department-of-veterans-affairs\'\n        this.repoName = repoName;   // e.g., \'va.gov-team\'\n        this.requiredLabels = requiredLabels;\n        this.storage = dbStorage;\n        // Initialize by loading from DB cache if desired\n        this.loadIssuesFromDbCache().catch(console.error);\n      }\n\n      private async loadIssuesFromDbCache() {\n        const dbIssues = await this.storage.getAllGithubIssues();\n        if (dbIssues && dbIssues.length > 0) {\n          this.inMemoryCache = dbIssues.map(issue => ({ ...issue, labels: issue.labels || [] }));\n          console.log(`GitHubService: Loaded ${this.inMemoryCache.length} issues from DB cache.`);\n        }\n      }\n\n      public async getCachedIssues(): Promise<{ issues: GitHubIssue[], lastRefreshed: string | null }> {\n        const latestDbIssue = await this.storage.getLatestGithubIssue();\n        const lastRefreshed = latestDbIssue ? latestDbIssue.fetched_at : null;\n        // Prefer in-memory cache if populated, otherwise fall back to DB\n        const issuesToReturn = this.inMemoryCache.length > 0 ? this.inMemoryCache : (await this.storage.getAllGithubIssues()).map(issue => ({ ...issue, labels: issue.labels || [] }));\n        return { issues: issuesToReturn, lastRefreshed };\n      }\n\n      public async refreshIssuesFromApi(): Promise<GitHubIssue[]> {\n        console.log(`GitHubService: Fetching issues for ${this.repoOwner}/${this.repoName} with labels: ${this.requiredLabels.join(\', \')}`);\n        // Implement actual GraphQL or REST API call to GitHub\n        // This is a simplified placeholder for the actual fetch logic from server/routes.ts\n        // Ensure to handle pagination if there are many issues.\n        const query = `...\`; // Your GraphQL query here\n        \n        // Example (conceptual - adapt existing fetchGitHubIssuesFromApi logic):\n        // const response = await fetch(this.GITHUB_API_URL, { ... });\n        // const data = await response.json();\n        // const fetchedIssues = parseGitHubData(data); // Implement parsing\n        const fetchedIssues: GitHubIssue[] = []; // Replace with actual fetched issues\n\n        this.inMemoryCache = fetchedIssues;\n        const currentTime = new Date().toISOString();\n        await this.storage.saveGithubIssues(fetchedIssues.map(issue => ({ ...issue, fetched_at: currentTime })));\n        console.log(`GitHubService: Refreshed and saved ${fetchedIssues.length} issues.`);\n        return fetchedIssues;\n      }\n\n      // Placeholder for actual API call and parsing logic\n      // private async fetchAndParseFromGitHubAPI(): Promise<GitHubIssue[]> { ... }\n    }\n\n    // Initialize and export the service instance (consider dependency injection for better testability)\n    // You might pass process.env.GITHUB_TOKEN directly here, or use a config module\n    // const GITHUB_REPO_PARTS = GITHUB_REPO.split(\'/\'); // Assuming GITHUB_REPO is \'owner/name\'\n    // export const gitHubService = new GitHubService(\n    //   process.env.GITHUB_TOKEN || \'\',\n    //   GITHUB_REPO_PARTS[0],\n    //   GITHUB_REPO_PARTS[1],\n    //   REQUIRED_LABELS, // from constants or config\n    //   storage\n    // ); \n    ```\n5.  **Update `server/routes.ts`**: Import and use `gitHubService` in the relevant route handlers.\n    ```typescript\n    // server/routes.ts\n    // import { gitHubService } from \'./services/githubService\'; // Adjust initialization\n    // ...\n    // app.get(\'/api/github/issues\', async (req, res) => {\n    //   try {\n    //     const { issues, lastRefreshed } = await gitHubService.getCachedIssues();\n    //     return res.json({ issues, lastRefreshed });\n    //   } catch (error) { /* ... */ }\n    // });\n    // ...\n    ```\n\n**Benefits**: \n*   **Separation of Concerns**: `routes.ts` focuses on routing and request/response handling.\n*   **Testability**: `githubService.ts` can be unit-tested independently.\n*   **Maintainability**: Easier to manage and update GitHub integration logic.\n*   **Reusability**: The service could be used elsewhere if needed.\n\n### 2. Configuration Management\n\nConsider centralizing configuration (like GitHub repo details, API keys) perhaps into a `server/config.ts` file that reads from environment variables, rather than having constants spread across files.\n\n### 3. Error Handling\n\nWhile basic error handling exists, a more robust and centralized error handling strategy could be implemented, potentially with custom error classes.\n\n### 4. Further Modularization of `routes.ts`\n\nIf `routes.ts` grows significantly, consider splitting it into multiple files based on resource types (e.g., `roadmapRoutes.ts`, `githubRoutes.ts`, `authRoutes.ts`) and then importing them into `index.ts` or a main router file.\n\n## Server Architecture Diagram (Post-Refactor for GitHub Service)\n\nThis diagram illustrates the proposed server architecture after refactoring the GitHub integration into a dedicated service.\n\n```mermaid\ngraph TD\n    subgraph ClientApp [Client Application]\n        direction LR\n        UI[User Interface]\n    end\n\n    subgraph ServerApp [Server (Node.js/Express)]\n        direction TB\n        A[Express App / Middleware (index.ts)] --> B(API Router /routes.ts);\n        \n        subgraph RouteHandlers [Route Handlers in routes.ts]\n            direction LR\n            R_Roadmap[/api/roadmap/*]\n            R_GitHub[/api/github/*]\n            R_Auth[/api/auth/*]\n        end\n        \n        B --> R_Roadmap;\n        B --> R_GitHub;\n        B --> R_Auth; \n\n        subgraph Services\n            direction TB\n            S_GitHub[GitHub Service (services/githubService.ts)]\n            S_Auth[Auth Service (services/authService.ts - hypothetical)]\n        end\n        \n        subgraph DataAccess\n            direction TB\n            DA_Storage[Storage Layer (storage.ts / Drizzle ORM)]\n        end\n\n        R_Roadmap --> DA_Storage;\n        R_GitHub --> S_GitHub;\n        R_Auth --> S_Auth; \n        S_Auth --> DA_Storage; \n\n        S_GitHub --> DA_Storage; # For caching GitHub issues in DB\n        \n    end\n\n    subgraph ExternalServices\n        direction TB\n        Ext_GitHub[GitHub API]\n        Ext_DB[(PostgreSQL / NeonDB)]\n    end\n\n    UI -- HTTP Requests --> A;\n    S_GitHub -- API Calls --> Ext_GitHub;\n    DA_Storage -- SQL --> Ext_DB;\n\n    classDef internal fill:#ddeeff,stroke:#333,stroke-width:2px;\n    classDef external fill:#ffeedd,stroke:#333,stroke-width:2px;\n    classDef service fill:#e6ffe6,stroke:#333,stroke-width:2px;\n\n    class A,B,R_Roadmap,R_GitHub,R_Auth internal;\n    class S_GitHub,S_Auth service;\n    class DA_Storage internal;\n    class Ext_GitHub,Ext_DB external;\n    class UI internal;\n```\n\nThis diagram shows:\n*   Client requests hitting the Express app.\n*   The API router directing requests to specific route handlers.\n*   Route handlers utilizing dedicated services (like the new `GitHubService`) for business logic.\n*   Services and route handlers interacting with the `Storage Layer` (Drizzle ORM) for database operations.\n*   The `GitHubService` communicating with the external GitHub API and also with the `Storage Layer` for caching.\n*   The `Storage Layer` communicating with the PostgreSQL database.\n 